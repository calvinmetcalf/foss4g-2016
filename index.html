<!DOCTYPE html>
<html>
<head>
  <title>Big</title>
  <meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
<link href='big.css' rel='stylesheet' type='text/css' />

<script src='big.js'></script></head><body>

<div>
  <em>Streams</em> and <em>You</em>:<br/> A <em>Love</em> Story<br/>
  <em>Calvin</em> W. <em>Metcalf</em><br/>
  Applied Geographics
</div>
<div>Who Am I?
<notes>Member of stream WG</notes>
<notes>Use streams all the time</notes>
<notes>Make a lot of maps</notes>
</div>
<div><img src="img/flatearth.jpg" />Less This<notes>source: https://commons.wikimedia.org/wiki/File:Orlando-Ferguson-flat-earth-map_edit.jpg</notes>
</div>
<div><img src="img/drivetexas.png" />More This <notes>https://drivetexas.org, I wrote the backend...using streams</notes></div>
<div>
What is a <em>stream</em>?
</div>
<div>

a <em>collection</em> of data
<notes>Kinda like an array</notes>
</div>
<div>
that may <em>not</em> be available all at <em>once</em>
<notes>it is not a callback or a promise</notes>
</div>


<div>
That can be pipelined
<notes>supports back pressure, and makes it different from a generator</notes>
</div>

<div>
that may not fit in memory
<notes>this is in many ways a killer feature</notes>
</div>
<div>
Using streams
</div>
<div>
Writable streams
<notes>streams that take data</notes>
</div>
<div>
<pre>
var writableFileStream = fs.createWriteStream(<em>'./path'</em>);>
var writableHttpStream = https.request({
  method: <em>'POST'</em>
});</pre>
<notes>node streams are all binary streams</notes>
<notes>ones from npm can take objects</notes>
</div>
<div>
<em>.write</em> method to add data
</div>
<div>
<em>.end</em> method when you are done
<notes>can also take some data</notes>
</div>
<div>Can give it a buffer, or a string</div>
<div>if you give it a string you can specify encoding
<notes>defaults to 'utf8', same encodings as buffers</notes>
</div>
<div>
you can also pass a callback
</div>
<div>
  <em>'finish'</em> event is emitted when it's done writing everything
  <notes>this will come up later</notes>

</div>
<div>
Readable streams
<notes>streams that provide data</notes>
</div>
<div>
<pre>var <em>readableFileStream</em> = fs.createReadStream(<em>'./path'</em>);
var <em>writableHttpStream</em> = https.request({
  method: <em>'POST'</em>
}, function(<em>readableHttpStream</em>) {
  // do stuff
});</pre>
</div>
<div>
<em>'data'</em> event is is emitted when a stream had data.
<notes>this causes the stream to get you data to emit as fast as possible</notes>
</div>
<div>
<em>'end'</em> event when there is no more
</div>
<div>
  grab all data into a buffer and call a callback
<pre>
var outData = [];
readableHttpStream
.on(<em>'data'</em>, data => outData.push(data))
.on(<em>'error'</em>, callback)
.end(<em>'end'</em>, () => callback(null, Buffer.concat(outData)));
</pre>
</div>
<div>back pressure
  <notes>when you (async) consume data slower then it is produced</notes>
</div>
<div>
don't do anything async inside a <em>data</em> event listener
</div>
<div>
pipeing allows you do do async stuff as it handles back pressure
</div>
<div>
pipe to to a simple write stream
<pre>
readableFileStream.pipe(new stream.Writable({
  write(<em>chunk</em>, encoding, <em>next</em>) {
    doSomethingAsync(chunk, next);
  }
}));
</pre>
</div>
<div>
transform streams allow you to do it in steps
</div>
<div>
<pre>
var transform = new stream.Transform({
  transform(<em>chunk</em>, encoding, <em>next</em>) {
    doElseSomethingAsync(chunk, (err, resp) => {
      if (err) {
        return next(err);
      }
      if (!resp) {
        return next();
      }
      if (!Array.isArray(resp)) {
        return next(null, resp);
      }
      for (let item of resp) {
        this.push(item);
      }
      next();
    });
  }
});
</pre>
</div>
<div>
  details
<pre>
  if (err) {
    return next(err);
  }
  if (!resp) {
    return next();
  }
  if (!Array.isArray(resp)) {
    return next(null, resp);
  }
  for (let item of resp) {
    this.push(item);
  }
  next();
</pre>
<notes>
next is a callback so can take an error
</notes>
<notes>if only emitting one thing, next can take a value</notes>
<notes>zero to Infinity things may be emitted</notes>
</div>
<div>
  <pre>
readableFileStream
.pipe(transform)
.pipe(new stream.Writable({
  write(<em>chunk</em>, encoding, <em>next</em>) {
    doSomethingAsync(chunk, next);
  }
}));
</pre></div>
  <div>
real life example: json stream of some sort
  </div>
  <div>
    <pre>
function makeJsonStream() {
  var first = true;
  return new stream.Transform({
    objectMode: true,
    transform(<em>chunk</em>, encoding, <em>next</em>) {
      if (first) {
        this.push('[');
        first = false;
      } else {
        this.push(',');
      }
      this.push(JSON.stringify(chunk));
      next();
    },
    flush(done) {
      this.push(']');
      done();
    }
  })
}
  </pre>
  <notes>lets break this down</notes>
  </div>
<div>
setup:
<pre>
function makeJsonStream() {
  var first = <em>true</em>;
  return new stream.Transform({
    objectMode: <em>true</em>,
</pre>
<notes>note the object mode</notes>
</div>
<div>
the transform:
<pre>
transform(<em>chunk</em>, encoding, <em>next</em>) {
  if (<em>first</em>) {
    this.push(<em>'['</em>);
    first = <em>false</em>;
  } else {
    this.push(<em>','</em>);
  }
  this.push(JSON.stringify(<em>chunk</em>));
  <em>next</em>();
}
</pre>
</div>
<div>
wrap up:
<pre>
    flush(<em>done</em>) {
      this.push(<em>']'</em>);
      <em>done</em>();
    }
  })
}
</pre>
</div>
<div>
real life pipeline examples:
</div>
<div>
<ol>
<li>read filenames from google cloud storage</li>
<li>download files</li>
<li>pull 6 different stats out of each file</li>
<li>write it to a csv</li>
<li>upload to cloud</li>
</ol>
</div>
<div>
<ol>
  <li>download geodata from ESRI server</li>
  <li>convert to sane format</li>
  <li>add some extra info like the date</li>
  <li>if it's a line make a second feature that is a point</li>
  <li>upload it to a server</li>
</ol>
</div>
<div>
request bodies are also writable Streams<pre>
app.get(<em>'/path.json'</em>, (req, res) => {
  res.type(<em>'json'</em>);
  getData()
  .pipe(JSONStream.stringify())
  .pipe(res);
})
</pre>
<notes>it's that easy</notes>
</div>
<div>
great places to use streams
</div>
<div>ETL tasks<notes>where the data could be massive</notes></div>
<div>user uploads<notes>where data could be massive</notes></div>
<div>any task where you only need a litle bit at a time</div>
<div>
<ul>
<li><a href="https://twitter.com/cwmma">@cwmma</a></li>
<li><a href="https://github.com/calvinmetcalf">github.com/calvinmetcalf</a></li>
<li><a href="https://npmjs.org/~cwmma">npmjs.org/~cwmma</a></li>
<li>this presentation: <a href="http://streams.how">streams.how</a></li>
<li><a href="https://github.com/calvinmetcalf/streams-a-love-story">more resources</a></li>
</ul>
</div>

</body>
</html>
