<!DOCTYPE html>
<html>
<head>
  <title>Big</title>
  <meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
<link href='big.css' rel='stylesheet' type='text/css' />

<script src='big.js'></script></head><body>

<div>
  <em>Streams</em> and <em>You</em>:<br/> A <em>Love</em> Story<br/>
  <em>Calvin</em> W. <em>Metcalf</em><br/>
  Applied Geographics
</div>
<div>Who Am I?
<notes>Member of stream WG</notes>
<notes>Use streams all the time</notes>
<notes>Make a lot of maps</notes>
</div>
<div><img src="img/flatearth.jpg" />Less This<notes>source: https://commons.wikimedia.org/wiki/File:Orlando-Ferguson-flat-earth-map_edit.jpg</notes>
</div>
<div><img src="img/drivetexas.png" />More This <notes>https://drivetexas.org, I wrote the backend...using streams</notes></div>
<div>
What is a <em>stream</em>?
</div>
<div>

a <em>collection</em> of data
<notes>Kinda like an array</notes>
</div>
<div>
that may <em>not</em> be available all at <em>once</em>
<notes>it is not a callback or a promise</notes>
</div>


<div>
That can be pipelined
<notes>supports back pressure, and makes it different from a generator</notes>
</div>

<div>
that may not fit in memory
<notes>this is in many ways a killer feature</notes>
</div>
<div>Two types of streams</div>
<div>Binary Streams<notes>Buffer, but not all at once</notes>

</div>
<div>Examples
  <ul>
  <li>large file read from disk</li>
  <li>download a file</li>
  <li>web requests in general</li>
</ul>
</div>
<div>
Object Streams<notes>Arrays, but not all at once</notes>
</div>
<div>
how to specify an object mode stream
<pre>
var stream = new YourStream({
  <em>objectMode: true</em>
});
</pre>
</div>
<div>
streams have gone through a couple (backwards compatable) versions <notes>streams 1, 2, and 3</notes>
</div>
<div>
you can get node streams with
<pre>var stream = require(<em>'stream'</em>);</pre>
<notes>version you get will depend on which version of node/browserify</notes>
</div>
<div>
or there is an npm package you can use
<pre>var stream = require(<em>'readable-stream'</em>);</pre>
<notes>version will always be the same, good for use with libraries</notes>
</div>
<div>
Stream basics:
</div>
<div>streams my produce data</div>
<div>streams my consume data</div>
<div>or both</div>
<div>
A <em>Readable</em> stream does what you'd expect
<pre>var <em>Readable</em> = stream.Readable;</pre></div>
<div>
likewise <em>Writable</em> stream
<pre>var <em>Writable</em> = stream.Writable;</pre></div>
<div>
A <em>Duplex</em> stream is both readable and writable
<pre>var <em>Duplex</em> = stream.Duplex</pre>
<notes>there are 2 special types of duplex streams included</notes>
</div>
<div>
A <em>PassThrough</em> stream is a simple stream that output whatever data put into it
<pre>var <em>PassThrough</em> = stream.PassThrough</pre>
<notes>This is suprisingly useful</notes>
</div>
<div>
A <em>Transform</em> stream is a stream which produces data based on what is put into it
<pre>var <em>Transform</em> = stream.Transform</pre>
<notes>This is your bread and butter of streams</notes>
</div>
<div>
Using <em>streams</em>:
</div>
<div>
All streams are event emitters
</div>
<div>
<em>Readable</em>, <em>Duplex</em>, and <em>Transform</em> streams may be read from.
</div>
<div>
calling <em>.read()</em> on a stream returns data if it's available, null otherwise
<notes>calling it this way will cause the stream to only get enough data to fill up an internal buffer</notes>
</div>
<div>
<em>'readable'</em> event is emitted when there is data available to be read
</div>
<div>
<em>'end'</em> event is emitted when there is no data left
</div>
<div>
<em>'data'</em> event is special as it causes the stream to enter <em>'flowing'</em> mode and emit data as soon as it's available.
</div>
<div>
<em>.pipe(dest)</em> method is uses to pass the contents of the stream to a writable stream as quickly as the writable stream will accept it.
</div>
<div>
<em>Writable</em>, <em>Duplex</em>, and <em>Transform</em> streams may be written to
</div>
<div>
calling <em>.write(data)</em> or <em>.write(data, callback)</em> writes a value to the stream.
</div>
<div>
calling <em>.end(callback)</em> or <em>.end(data)</em> or <em>.end(data, callback)</em> closes the write stream (and optionally writes a last value).
</div>
<div>
<em>'finish'</em> event is emitted when the stream is no longer writable.
<notes>Yes this is super confusing</notes>
</div>
<div>
Intermezzo: <em>Pipeing</em> and <em>Back pressure</em>
<notes>no you haven't stumbled into a python talk</notes>
</div>
<div>
pipeing returns the destination stream
<pre>src.pipe(<em>dest</em>) === <em>dest</em></pre>
</div>
<div>
this allows for chaining
<pre><em>readable</em>.pipe(<em>transform</em>).pipe(<em>writable</em>)</pre>
</div>
<div>
<em>back pressure</em> is what happends when a readable stream produces data faster then a writable stream can consume it.
<notes>Usually when the writable stream is doing something async</notes>
</div>
<div>
<em>OK</em> not going to be a problem
<pre>stream.on('data', data => {
  var result = <em>doSomethingSync</em>(data);
  <em>doSomethingElse</em>(result);
});</pre>
</div>
<div>
<em>BAD!</em> Will cause an error with enough data
<pre>stream.on('data', data =>
  <em>doSomethingAsync</em>(data, (err, result) => {
    if (err) {
      throw err;
    }
    <em>doSomethingElseSync</em>(result);
  })
);</pre>
</div>
<div>
<em>Best</em> the prefered way
<pre>stream
  .pipe(<em>doSomethingAsyncStream</em>)
  .pipe(<em>doSomethingElseStream</em>);</pre>
</div>
<div>
To create a stream you just suply needed functions
</div>
<div>
<em>read</em> for a <em>Readable</em> stream
</div>
<div>
<em>write</em> (and optionally <em>writev</em>) for a <em>Writable</em> stream
</div>
<div>
<em>transform</em> (and optionally <em>flush</em>) for a <em>Transform</em> stream
</div>
<div>
You can either subclass the stream and supply this missing function as a method with an underscore in front of it
</div>
<div>
ES5 way
<pre>
utils.inherits(<em>FromArray</em>, <em>Transform</em>);
function <em>FromArray</em>() {
  <em>Transform</em>.call(<em>this</em>, {
    <em>objectMode</em>: true
  });
}
<em>FromArray</em>.prototype._transform = function (<em>chunk</em>, encoding, <em>next</em>) {
  for (let <em>item</em> of <em>chunk</em>) {
    <em>this</em>.push(<em>item</em>);
  }
  <em>next</em>();
}
</pre>
<notes>Note how we don't care about encoding?</notes>
</div>
<div>
ES2015 way
<pre>
class <em>FromArray</em> extends <em>Transform</em> {
  constructor() {
    <em>super</em>({
      <em>objectMode</em>: true
    });
  }
  _transform(<em>chunk</em>, encoding, <em>next</em>) {
    for (let <em>item</em> of <em>chunk</em>) {
      <em>this</em>.push(<em>item</em>);
    }
    <em>next</em>();
  }
}
</pre>
</div>
<div>
or you can just pass it to the constructor
<pre>
var <em>fromArray</em> = new <em>Transform</em>({
  <em>objectMode</em>: true,
  transform(<em>chunk</em>, encoding, <em>next</em>) {
    for (let <em>item</em> of <em>chunk</em>) {
      <em>this</em>.push(<em>item</em>);
    }
    <em>next</em>();
  }
});
</pre>
</div>
<div>
more complete transform function
<pre>function(<em>chunk</em>, encoding, <em>next</em>) {
    if (!Array.isArray(<em>chunk</em>)) {
      return <em>next</em>(new TypeError('must be an array'));
    }
    if (<em>chunk</em>.length === 1) {
      return <em>next</em>(null, <em>chunk</em>[0]);
    }
    for (let <em>item</em> of <em>chunk</em>) {
      <em>this</em>.push(<em>item</em>);
    }
    <em>next</em>();
  }<pre>
<notes>See how next is regular callback that can be used when we emit a single thing</notes>
<notes>if you forget to call next things will catch fire</notes>

</div>
</body>
</html>
<!--

<div>

<notes></notes>
</div>
-->
